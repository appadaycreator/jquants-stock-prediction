#!/usr/bin/env python3
"""
ÂÄãÂà•ÈäòÊüÑ„ÅÆÁõ∏Èñ¢ÂàÜÊûê„Å´„Çà„ÇãÂàÜÊï£ÊäïË≥áÊé®Â•®„Ç∑„Çπ„ÉÜ„É†
ÊúüÂæÖÂäπÊûú: ÊêçÂ§±„Çí60-80%ÂâäÊ∏õ
ÂÆüË£ÖÈõ£ÊòìÂ∫¶: üü° ‰∏≠
Êé®ÂÆöÂ∑•Êï∞: 2-3Êó•

Ê©üËÉΩ:
1. ÈäòÊüÑÈñìÁõ∏Èñ¢ÂàÜÊûê
2. „Éù„Éº„Éà„Éï„Ç©„É™„Ç™ÈõÜ‰∏≠Â∫¶ÂàÜÊûê
3. ÂàÜÊï£ÊäïË≥áÊé®Â•®
4. „Çª„ÇØ„Çø„ÉºÂàÜÊï£ÂàÜÊûê
5. Áõ∏Èñ¢„É™„Çπ„ÇØÁõ£Ë¶ñ
"""

import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from typing import Dict, List, Tuple, Optional, Any
import json
import logging
from dataclasses import dataclass, asdict
from enum import Enum
import warnings
from collections import defaultdict, deque
import yfinance as yf
from scipy import stats
from scipy.stats import pearsonr
from scipy.cluster.hierarchy import linkage, dendrogram
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
import asyncio
import aiohttp
import networkx as nx

warnings.filterwarnings("ignore")

# „É≠„Ç∞Ë®≠ÂÆö
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("correlation_analysis_system.log"),
        logging.StreamHandler(),
    ],
)
logger = logging.getLogger(__name__)


class CorrelationLevel(Enum):
    """Áõ∏Èñ¢„É¨„Éô„É´"""
    VERY_LOW = "VERY_LOW"      # 0.0-0.2
    LOW = "LOW"                # 0.2-0.4
    MODERATE = "MODERATE"      # 0.4-0.6
    HIGH = "HIGH"              # 0.6-0.8
    VERY_HIGH = "VERY_HIGH"    # 0.8-1.0


class DiversificationLevel(Enum):
    """ÂàÜÊï£ÊäïË≥á„É¨„Éô„É´"""
    EXCELLENT = "EXCELLENT"    # ÂàÜÊï£Â∫¶90%‰ª•‰∏ä
    GOOD = "GOOD"              # ÂàÜÊï£Â∫¶70-90%
    FAIR = "FAIR"              # ÂàÜÊï£Â∫¶50-70%
    POOR = "POOR"              # ÂàÜÊï£Â∫¶30-50%
    CRITICAL = "CRITICAL"      # ÂàÜÊï£Â∫¶30%Êú™Ê∫Ä


class SectorType(Enum):
    """„Çª„ÇØ„Çø„Éº„Çø„Ç§„Éó"""
    TECHNOLOGY = "TECHNOLOGY"
    FINANCIAL = "FINANCIAL"
    HEALTHCARE = "HEALTHCARE"
    CONSUMER = "CONSUMER"
    INDUSTRIAL = "INDUSTRIAL"
    ENERGY = "ENERGY"
    MATERIALS = "MATERIALS"
    UTILITIES = "UTILITIES"
    REAL_ESTATE = "REAL_ESTATE"
    COMMUNICATION = "COMMUNICATION"
    UNKNOWN = "UNKNOWN"


@dataclass
class CorrelationMetrics:
    """Áõ∏Èñ¢ÊåáÊ®ô"""
    symbol: str
    timestamp: datetime
    correlation_matrix: Dict[str, Dict[str, float]]
    average_correlation: float
    max_correlation: float
    correlation_risk_score: float
    diversification_score: float
    concentration_risk: float
    sector_concentration: Dict[SectorType, float]
    cluster_analysis: Dict[str, Any]


@dataclass
class DiversificationRecommendation:
    """ÂàÜÊï£ÊäïË≥áÊé®Â•®"""
    symbol: str
    timestamp: datetime
    current_diversification_level: DiversificationLevel
    recommended_actions: List[str]
    suggested_sectors: List[SectorType]
    suggested_stocks: List[str]
    risk_reduction_potential: float
    priority_score: float


@dataclass
class PortfolioConcentration:
    """„Éù„Éº„Éà„Éï„Ç©„É™„Ç™ÈõÜ‰∏≠Â∫¶"""
    total_stocks: int
    sector_distribution: Dict[SectorType, int]
    concentration_ratio: float
    herfindahl_index: float
    effective_diversification: int
    concentration_risk_level: str


class CorrelationAnalysisSystem:
    """Áõ∏Èñ¢ÂàÜÊûê„Ç∑„Çπ„ÉÜ„É†"""

    def __init__(self, lookback_period: int = 252):
        self.lookback_period = lookback_period
        self.correlation_history = defaultdict(list)
        self.sector_mapping = self._initialize_sector_mapping()
        self.correlation_thresholds = {
            "very_low": 0.2,
            "low": 0.4,
            "moderate": 0.6,
            "high": 0.8,
            "very_high": 1.0,
        }
        
        # ÂàÜÊï£ÊäïË≥á„Éë„É©„É°„Éº„Çø
        self.diversification_params = {
            "min_stocks": 5,
            "optimal_stocks": 15,
            "max_sector_weight": 0.3,
            "target_correlation": 0.3,
        }

    def _initialize_sector_mapping(self) -> Dict[str, SectorType]:
        """„Çª„ÇØ„Çø„Éº„Éû„ÉÉ„Éî„É≥„Ç∞ÂàùÊúüÂåñ"""
        # Á∞°ÊòìÂÆüË£Ö: ÂÆüÈöõ„ÅÆÂÆüË£Ö„Åß„ÅØ„Çà„ÇäË©≥Á¥∞„Å™„Çª„ÇØ„Çø„ÉºÂàÜÈ°û„ÅåÂøÖË¶Å
        return {
            # „ÉÜ„ÇØ„Éé„É≠„Ç∏„Éº
            "AAPL": SectorType.TECHNOLOGY,
            "GOOGL": SectorType.TECHNOLOGY,
            "MSFT": SectorType.TECHNOLOGY,
            "AMZN": SectorType.TECHNOLOGY,
            "TSLA": SectorType.TECHNOLOGY,
            "NVDA": SectorType.TECHNOLOGY,
            "META": SectorType.TECHNOLOGY,
            "NFLX": SectorType.TECHNOLOGY,
            
            # ÈáëËûç
            "JPM": SectorType.FINANCIAL,
            "BAC": SectorType.FINANCIAL,
            "WFC": SectorType.FINANCIAL,
            "GS": SectorType.FINANCIAL,
            "C": SectorType.FINANCIAL,
            
            # „Éò„É´„Çπ„Ç±„Ç¢
            "JNJ": SectorType.HEALTHCARE,
            "PFE": SectorType.HEALTHCARE,
            "UNH": SectorType.HEALTHCARE,
            "ABBV": SectorType.HEALTHCARE,
            "MRK": SectorType.HEALTHCARE,
            
            # Êó•Êú¨Ê†™
            "7203.T": SectorType.TECHNOLOGY,  # „Éà„É®„Çø
            "6758.T": SectorType.TECHNOLOGY,  # „ÇΩ„Éã„Éº
            "9984.T": SectorType.TECHNOLOGY,   # „ÇΩ„Éï„Éà„Éê„É≥„ÇØG
            "7974.T": SectorType.CONSUMER,      # ‰ªªÂ§©Â†Ç
            "4063.T": SectorType.TECHNOLOGY,   # ‰ø°Ë∂äÂåñÂ≠¶
        }

    async def analyze_correlation_risk(self, symbols: List[str]) -> CorrelationMetrics:
        """Áõ∏Èñ¢„É™„Çπ„ÇØÂàÜÊûê"""
        try:
            logger.info(f"Áõ∏Èñ¢„É™„Çπ„ÇØÂàÜÊûêÈñãÂßã: {len(symbols)}ÈäòÊüÑ")
            
            # Áõ∏Èñ¢Ë°åÂàóË®àÁÆó
            correlation_matrix = await self._calculate_correlation_matrix(symbols)
            
            # Âπ≥ÂùáÁõ∏Èñ¢Ë®àÁÆó
            average_correlation = self._calculate_average_correlation(correlation_matrix)
            
            # ÊúÄÂ§ßÁõ∏Èñ¢Ë®àÁÆó
            max_correlation = self._calculate_max_correlation(correlation_matrix)
            
            # Áõ∏Èñ¢„É™„Çπ„ÇØ„Çπ„Ç≥„Ç¢Ë®àÁÆó
            correlation_risk_score = self._calculate_correlation_risk_score(
                average_correlation, max_correlation, len(symbols)
            )
            
            # ÂàÜÊï£ÊäïË≥á„Çπ„Ç≥„Ç¢Ë®àÁÆó
            diversification_score = self._calculate_diversification_score(
                correlation_matrix, symbols
            )
            
            # ÈõÜ‰∏≠Â∫¶„É™„Çπ„ÇØË®àÁÆó
            concentration_risk = self._calculate_concentration_risk(symbols)
            
            # „Çª„ÇØ„Çø„ÉºÈõÜ‰∏≠Â∫¶Ë®àÁÆó
            sector_concentration = self._calculate_sector_concentration(symbols)
            
            # „ÇØ„É©„Çπ„Çø„ÉºÂàÜÊûê
            cluster_analysis = await self._perform_cluster_analysis(symbols, correlation_matrix)
            
            # Áõ∏Èñ¢ÊåáÊ®ô‰ΩúÊàê
            metrics = CorrelationMetrics(
                symbol="PORTFOLIO",  # „Éù„Éº„Éà„Éï„Ç©„É™„Ç™ÂÖ®‰Ωì
                timestamp=datetime.now(),
                correlation_matrix=correlation_matrix,
                average_correlation=average_correlation,
                max_correlation=max_correlation,
                correlation_risk_score=correlation_risk_score,
                diversification_score=diversification_score,
                concentration_risk=concentration_risk,
                sector_concentration=sector_concentration,
                cluster_analysis=cluster_analysis,
            )
            
            # Â±•Ê≠¥„Å´ËøΩÂä†
            self.correlation_history["PORTFOLIO"].append(metrics)
            
            logger.info(f"Áõ∏Èñ¢ÂàÜÊûêÂÆå‰∫Ü: Âπ≥ÂùáÁõ∏Èñ¢ {average_correlation:.3f}, "
                       f"ÂàÜÊï£„Çπ„Ç≥„Ç¢ {diversification_score:.3f}")
            return metrics

        except Exception as e:
            logger.error(f"Áõ∏Èñ¢„É™„Çπ„ÇØÂàÜÊûê„Ç®„É©„Éº: {e}")
            return self._create_default_correlation_metrics()

    async def _calculate_correlation_matrix(self, symbols: List[str]) -> Dict[str, Dict[str, float]]:
        """Áõ∏Èñ¢Ë°åÂàóË®àÁÆó"""
        try:
            correlation_matrix = {}
            
            # ÂêÑÈäòÊüÑ„ÅÆ‰æ°Ê†º„Éá„Éº„ÇøÂèñÂæó
            price_data = {}
            for symbol in symbols:
                try:
                    stock = yf.Ticker(symbol)
                    hist = stock.history(period="6mo")
                    if len(hist) > 30:
                        price_data[symbol] = hist['Close']
                except Exception as e:
                    logger.warning(f"‰æ°Ê†º„Éá„Éº„ÇøÂèñÂæó„Ç®„É©„Éº: {symbol} - {e}")
                    continue
            
            if len(price_data) < 2:
                return {}
            
            # ÂÖ±ÈÄöÊúüÈñì„ÅÆ„Éá„Éº„Çø„ÇíÂèñÂæó
            common_dates = None
            for symbol, prices in price_data.items():
                if common_dates is None:
                    common_dates = prices.index
                else:
                    common_dates = common_dates.intersection(prices.index)
            
            if len(common_dates) < 30:
                return {}
            
            # Áõ∏Èñ¢Ë®àÁÆó
            for symbol1 in price_data.keys():
                correlation_matrix[symbol1] = {}
                for symbol2 in price_data.keys():
                    if symbol1 == symbol2:
                        correlation_matrix[symbol1][symbol2] = 1.0
                    else:
                        try:
                            returns1 = price_data[symbol1].loc[common_dates].pct_change().dropna()
                            returns2 = price_data[symbol2].loc[common_dates].pct_change().dropna()
                            
                            if len(returns1) > 10 and len(returns2) > 10:
                                correlation, _ = pearsonr(returns1, returns2)
                                correlation_matrix[symbol1][symbol2] = correlation if not np.isnan(correlation) else 0.0
                            else:
                                correlation_matrix[symbol1][symbol2] = 0.0
                        except Exception as e:
                            logger.warning(f"Áõ∏Èñ¢Ë®àÁÆó„Ç®„É©„Éº: {symbol1} vs {symbol2} - {e}")
                            correlation_matrix[symbol1][symbol2] = 0.0
            
            return correlation_matrix
        except Exception as e:
            logger.error(f"Áõ∏Èñ¢Ë°åÂàóË®àÁÆó„Ç®„É©„Éº: {e}")
            return {}

    def _calculate_average_correlation(self, correlation_matrix: Dict[str, Dict[str, float]]) -> float:
        """Âπ≥ÂùáÁõ∏Èñ¢Ë®àÁÆó"""
        try:
            if not correlation_matrix:
                return 0.0
            
            correlations = []
            for symbol1, correlations_dict in correlation_matrix.items():
                for symbol2, correlation in correlations_dict.items():
                    if symbol1 != symbol2:  # Ëá™Â∑±Áõ∏Èñ¢„ÇíÈô§Â§ñ
                        correlations.append(abs(correlation))  # Áµ∂ÂØæÂÄ§„Çí‰ΩøÁî®
            
            return np.mean(correlations) if correlations else 0.0
        except Exception as e:
            logger.error(f"Âπ≥ÂùáÁõ∏Èñ¢Ë®àÁÆó„Ç®„É©„Éº: {e}")
            return 0.0

    def _calculate_max_correlation(self, correlation_matrix: Dict[str, Dict[str, float]]) -> float:
        """ÊúÄÂ§ßÁõ∏Èñ¢Ë®àÁÆó"""
        try:
            if not correlation_matrix:
                return 0.0
            
            max_corr = 0.0
            for symbol1, correlations_dict in correlation_matrix.items():
                for symbol2, correlation in correlations_dict.items():
                    if symbol1 != symbol2:  # Ëá™Â∑±Áõ∏Èñ¢„ÇíÈô§Â§ñ
                        max_corr = max(max_corr, abs(correlation))
            
            return max_corr
        except Exception as e:
            logger.error(f"ÊúÄÂ§ßÁõ∏Èñ¢Ë®àÁÆó„Ç®„É©„Éº: {e}")
            return 0.0

    def _calculate_correlation_risk_score(
        self, average_correlation: float, max_correlation: float, num_stocks: int
    ) -> float:
        """Áõ∏Èñ¢„É™„Çπ„ÇØ„Çπ„Ç≥„Ç¢Ë®àÁÆó"""
        try:
            # Âπ≥ÂùáÁõ∏Èñ¢„Å´„Çà„Çã„É™„Çπ„ÇØÔºà40%„ÅÆÈáç„ÅøÔºâ
            avg_corr_risk = min(average_correlation, 1.0) * 0.4
            
            # ÊúÄÂ§ßÁõ∏Èñ¢„Å´„Çà„Çã„É™„Çπ„ÇØÔºà30%„ÅÆÈáç„ÅøÔºâ
            max_corr_risk = min(max_correlation, 1.0) * 0.3
            
            # ÈäòÊüÑÊï∞„Å´„Çà„Çã„É™„Çπ„ÇØÔºà30%„ÅÆÈáç„ÅøÔºâ
            stock_count_risk = max(0, (self.diversification_params["min_stocks"] - num_stocks) / 
                                 self.diversification_params["min_stocks"]) * 0.3
            
            # Á∑èÂêà„É™„Çπ„ÇØ„Çπ„Ç≥„Ç¢
            total_risk = avg_corr_risk + max_corr_risk + stock_count_risk
            
            return min(total_risk, 1.0)
        except Exception as e:
            logger.error(f"Áõ∏Èñ¢„É™„Çπ„ÇØ„Çπ„Ç≥„Ç¢Ë®àÁÆó„Ç®„É©„Éº: {e}")
            return 0.5

    def _calculate_diversification_score(
        self, correlation_matrix: Dict[str, Dict[str, float]], symbols: List[str]
    ) -> float:
        """ÂàÜÊï£ÊäïË≥á„Çπ„Ç≥„Ç¢Ë®àÁÆó"""
        try:
            if not correlation_matrix or len(symbols) < 2:
                return 0.0
            
            # Âπ≥ÂùáÁõ∏Èñ¢„ÅÆÈÄÜÊï∞Ôºà‰Ωé„ÅÑÁõ∏Èñ¢„Åª„Å©È´ò„ÅÑÂàÜÊï£„Çπ„Ç≥„Ç¢Ôºâ
            avg_correlation = self._calculate_average_correlation(correlation_matrix)
            correlation_score = 1 - avg_correlation
            
            # ÈäòÊüÑÊï∞„Å´„Çà„ÇãÂàÜÊï£„Çπ„Ç≥„Ç¢
            stock_count_score = min(len(symbols) / self.diversification_params["optimal_stocks"], 1.0)
            
            # „Çª„ÇØ„Çø„ÉºÂàÜÊï£„Çπ„Ç≥„Ç¢
            sector_diversity_score = self._calculate_sector_diversity_score(symbols)
            
            # Á∑èÂêàÂàÜÊï£„Çπ„Ç≥„Ç¢
            total_score = (correlation_score * 0.5 + stock_count_score * 0.3 + sector_diversity_score * 0.2)
            
            return min(total_score, 1.0)
        except Exception as e:
            logger.error(f"ÂàÜÊï£ÊäïË≥á„Çπ„Ç≥„Ç¢Ë®àÁÆó„Ç®„É©„Éº: {e}")
            return 0.5

    def _calculate_sector_diversity_score(self, symbols: List[str]) -> float:
        """„Çª„ÇØ„Çø„ÉºÂàÜÊï£„Çπ„Ç≥„Ç¢Ë®àÁÆó"""
        try:
            # ÂêÑÈäòÊüÑ„ÅÆ„Çª„ÇØ„Çø„Éº„ÇíÂèñÂæó
            sectors = []
            for symbol in symbols:
                sector = self.sector_mapping.get(symbol, SectorType.UNKNOWN)
                sectors.append(sector)
            
            # „Çª„ÇØ„Çø„Éº„ÅÆÂ§öÊßòÊÄßË®àÁÆó
            unique_sectors = set(sectors)
            sector_diversity = len(unique_sectors) / len(SectorType)
            
            # „Çª„ÇØ„Çø„ÉºÂàÜÂ∏É„ÅÆÂùáÁ≠âÊÄß
            sector_counts = {}
            for sector in sectors:
                sector_counts[sector] = sector_counts.get(sector, 0) + 1
            
            # „Ç®„É≥„Éà„É≠„Éî„ÉºË®àÁÆó
            total_stocks = len(symbols)
            entropy = 0.0
            for count in sector_counts.values():
                if count > 0:
                    p = count / total_stocks
                    entropy -= p * np.log2(p)
            
            # Ê≠£Ë¶èÂåñ„Åï„Çå„Åü„Ç®„É≥„Éà„É≠„Éî„Éº
            max_entropy = np.log2(len(unique_sectors)) if len(unique_sectors) > 1 else 1.0
            normalized_entropy = entropy / max_entropy if max_entropy > 0 else 0.0
            
            # Á∑èÂêà„Çª„ÇØ„Çø„ÉºÂàÜÊï£„Çπ„Ç≥„Ç¢
            total_score = (sector_diversity * 0.6 + normalized_entropy * 0.4)
            
            return min(total_score, 1.0)
        except Exception as e:
            logger.error(f"„Çª„ÇØ„Çø„ÉºÂàÜÊï£„Çπ„Ç≥„Ç¢Ë®àÁÆó„Ç®„É©„Éº: {e}")
            return 0.5

    def _calculate_concentration_risk(self, symbols: List[str]) -> float:
        """ÈõÜ‰∏≠Â∫¶„É™„Çπ„ÇØË®àÁÆó"""
        try:
            # ÈäòÊüÑÊï∞„Å´„Çà„ÇãÈõÜ‰∏≠Â∫¶„É™„Çπ„ÇØ
            stock_count_risk = max(0, (self.diversification_params["min_stocks"] - len(symbols)) / 
                                 self.diversification_params["min_stocks"])
            
            # „Çª„ÇØ„Çø„ÉºÈõÜ‰∏≠Â∫¶„É™„Çπ„ÇØ
            sector_concentration = self._calculate_sector_concentration(symbols)
            max_sector_weight = max(sector_concentration.values()) if sector_concentration else 0.0
            sector_risk = max(0, (max_sector_weight - self.diversification_params["max_sector_weight"]) / 
                            self.diversification_params["max_sector_weight"])
            
            # Á∑èÂêàÈõÜ‰∏≠Â∫¶„É™„Çπ„ÇØ
            total_risk = (stock_count_risk * 0.6 + sector_risk * 0.4)
            
            return min(total_risk, 1.0)
        except Exception as e:
            logger.error(f"ÈõÜ‰∏≠Â∫¶„É™„Çπ„ÇØË®àÁÆó„Ç®„É©„Éº: {e}")
            return 0.5

    def _calculate_sector_concentration(self, symbols: List[str]) -> Dict[SectorType, float]:
        """„Çª„ÇØ„Çø„ÉºÈõÜ‰∏≠Â∫¶Ë®àÁÆó"""
        try:
            sector_counts = {}
            for symbol in symbols:
                sector = self.sector_mapping.get(symbol, SectorType.UNKNOWN)
                sector_counts[sector] = sector_counts.get(sector, 0) + 1
            
            # Ââ≤Âêà„Å´Â§âÊèõ
            total_stocks = len(symbols)
            sector_concentration = {
                sector: count / total_stocks 
                for sector, count in sector_counts.items()
            }
            
            return sector_concentration
        except Exception as e:
            logger.error(f"„Çª„ÇØ„Çø„ÉºÈõÜ‰∏≠Â∫¶Ë®àÁÆó„Ç®„É©„Éº: {e}")
            return {}

    async def _perform_cluster_analysis(
        self, symbols: List[str], correlation_matrix: Dict[str, Dict[str, float]]
    ) -> Dict[str, Any]:
        """„ÇØ„É©„Çπ„Çø„ÉºÂàÜÊûêÂÆüË°å"""
        try:
            if len(symbols) < 3:
                return {"clusters": [], "cluster_count": 0}
            
            # Áõ∏Èñ¢Ë°åÂàó„ÇíË∑ùÈõ¢Ë°åÂàó„Å´Â§âÊèõ
            distance_matrix = []
            for i, symbol1 in enumerate(symbols):
                row = []
                for j, symbol2 in enumerate(symbols):
                    if i == j:
                        row.append(0.0)
                    else:
                        correlation = correlation_matrix.get(symbol1, {}).get(symbol2, 0.0)
                        distance = 1 - abs(correlation)  # Áõ∏Èñ¢„ÇíË∑ùÈõ¢„Å´Â§âÊèõ
                        row.append(distance)
                distance_matrix.append(row)
            
            # K-means„ÇØ„É©„Çπ„Çø„É™„É≥„Ç∞
            if len(symbols) >= 3:
                n_clusters = min(3, len(symbols) // 2)  # ÊúÄÂ§ß3„ÇØ„É©„Çπ„Çø„Éº
                kmeans = KMeans(n_clusters=n_clusters, random_state=42)
                cluster_labels = kmeans.fit_predict(distance_matrix)
                
                # „ÇØ„É©„Çπ„Çø„ÉºÁµêÊûú„ÅÆÊï¥ÁêÜ
                clusters = {}
                for i, symbol in enumerate(symbols):
                    cluster_id = cluster_labels[i]
                    if cluster_id not in clusters:
                        clusters[cluster_id] = []
                    clusters[cluster_id].append(symbol)
                
                return {
                    "clusters": list(clusters.values()),
                    "cluster_count": n_clusters,
                    "cluster_labels": cluster_labels.tolist(),
                }
            else:
                return {"clusters": [symbols], "cluster_count": 1}
                
        except Exception as e:
            logger.error(f"„ÇØ„É©„Çπ„Çø„ÉºÂàÜÊûê„Ç®„É©„Éº: {e}")
            return {"clusters": [], "cluster_count": 0}

    async def generate_diversification_recommendations(
        self, symbols: List[str], current_portfolio_value: float = 1000000
    ) -> List[DiversificationRecommendation]:
        """ÂàÜÊï£ÊäïË≥áÊé®Â•®ÁîüÊàê"""
        try:
            logger.info(f"ÂàÜÊï£ÊäïË≥áÊé®Â•®ÁîüÊàêÈñãÂßã: {len(symbols)}ÈäòÊüÑ")
            
            recommendations = []
            
            # ÁèæÂú®„ÅÆÂàÜÊï£ÊäïË≥á„É¨„Éô„É´Ë©ï‰æ°
            current_level = self._evaluate_diversification_level(symbols)
            
            # ÂêÑÈäòÊüÑ„Å´ÂØæ„Åô„ÇãÊé®Â•®‰∫ãÈ†ÖÁîüÊàê
            for symbol in symbols:
                recommendation = await self._generate_individual_recommendation(
                    symbol, symbols, current_level, current_portfolio_value
                )
                recommendations.append(recommendation)
            
            # „Éù„Éº„Éà„Éï„Ç©„É™„Ç™ÂÖ®‰Ωì„ÅÆÊé®Â•®‰∫ãÈ†Ö
            portfolio_recommendation = await self._generate_portfolio_recommendation(
                symbols, current_level, current_portfolio_value
            )
            recommendations.append(portfolio_recommendation)
            
            logger.info(f"ÂàÜÊï£ÊäïË≥áÊé®Â•®ÁîüÊàêÂÆå‰∫Ü: {len(recommendations)}‰ª∂")
            return recommendations

        except Exception as e:
            logger.error(f"ÂàÜÊï£ÊäïË≥áÊé®Â•®ÁîüÊàê„Ç®„É©„Éº: {e}")
            return []

    def _evaluate_diversification_level(self, symbols: List[str]) -> DiversificationLevel:
        """ÂàÜÊï£ÊäïË≥á„É¨„Éô„É´Ë©ï‰æ°"""
        try:
            # ÈäòÊüÑÊï∞„Å´„Çà„ÇãË©ï‰æ°
            stock_count_score = len(symbols) / self.diversification_params["optimal_stocks"]
            
            # „Çª„ÇØ„Çø„ÉºÂàÜÊï£„Å´„Çà„ÇãË©ï‰æ°
            sector_diversity_score = self._calculate_sector_diversity_score(symbols)
            
            # Á∑èÂêàÂàÜÊï£„Çπ„Ç≥„Ç¢
            total_score = (stock_count_score * 0.6 + sector_diversity_score * 0.4)
            
            # ÂàÜÊï£ÊäïË≥á„É¨„Éô„É´Âà§ÂÆö
            if total_score >= 0.9:
                return DiversificationLevel.EXCELLENT
            elif total_score >= 0.7:
                return DiversificationLevel.GOOD
            elif total_score >= 0.5:
                return DiversificationLevel.FAIR
            elif total_score >= 0.3:
                return DiversificationLevel.POOR
            else:
                return DiversificationLevel.CRITICAL
                
        except Exception as e:
            logger.error(f"ÂàÜÊï£ÊäïË≥á„É¨„Éô„É´Ë©ï‰æ°„Ç®„É©„Éº: {e}")
            return DiversificationLevel.POOR

    async def _generate_individual_recommendation(
        self, symbol: str, all_symbols: List[str], current_level: DiversificationLevel,
        portfolio_value: float
    ) -> DiversificationRecommendation:
        """ÂÄãÂà•ÈäòÊüÑÊé®Â•®‰∫ãÈ†ÖÁîüÊàê"""
        try:
            # ÁèæÂú®„ÅÆ„Çª„ÇØ„Çø„Éº
            current_sector = self.sector_mapping.get(symbol, SectorType.UNKNOWN)
            
            # Êé®Â•®„Ç¢„ÇØ„Ç∑„Éß„É≥
            recommended_actions = []
            
            # „Çª„ÇØ„Çø„ÉºÈõÜ‰∏≠Â∫¶„ÉÅ„Çß„ÉÉ„ÇØ
            sector_concentration = self._calculate_sector_concentration(all_symbols)
            current_sector_weight = sector_concentration.get(current_sector, 0.0)
            
            if current_sector_weight > self.diversification_params["max_sector_weight"]:
                recommended_actions.append(f"{current_sector.value}„Çª„ÇØ„Çø„Éº„ÅÆÈõÜ‰∏≠Â∫¶„ÅåÈ´ò„Åô„Åé„Åæ„Åô")
                recommended_actions.append("Áï∞„Å™„Çã„Çª„ÇØ„Çø„Éº„Å∏„ÅÆÂàÜÊï£ÊäïË≥á„ÇíÊ§úË®é„Åó„Å¶„Åè„Å†„Åï„ÅÑ")
            
            # ÈäòÊüÑÊï∞‰∏çË∂≥„ÉÅ„Çß„ÉÉ„ÇØ
            if len(all_symbols) < self.diversification_params["min_stocks"]:
                recommended_actions.append("ÈäòÊüÑÊï∞„Åå‰∏çË∂≥„Åó„Å¶„ÅÑ„Åæ„Åô")
                recommended_actions.append("ËøΩÂä†ÈäòÊüÑ„ÅÆÊ§úË®é„ÇíÊé®Â•®„Åó„Åæ„Åô")
            
            # Êé®Â•®„Çª„ÇØ„Çø„Éº
            suggested_sectors = self._get_suggested_sectors(current_sector, sector_concentration)
            
            # Êé®Â•®ÈäòÊüÑÔºàÁ∞°ÊòìÂÆüË£ÖÔºâ
            suggested_stocks = self._get_suggested_stocks(suggested_sectors)
            
            # „É™„Çπ„ÇØÂâäÊ∏õ„Éù„ÉÜ„É≥„Ç∑„É£„É´
            risk_reduction = self._calculate_risk_reduction_potential(symbol, all_symbols)
            
            # ÂÑ™ÂÖàÂ∫¶„Çπ„Ç≥„Ç¢
            priority_score = self._calculate_priority_score(
                symbol, current_level, risk_reduction
            )
            
            return DiversificationRecommendation(
                symbol=symbol,
                timestamp=datetime.now(),
                current_diversification_level=current_level,
                recommended_actions=recommended_actions,
                suggested_sectors=suggested_sectors,
                suggested_stocks=suggested_stocks,
                risk_reduction_potential=risk_reduction,
                priority_score=priority_score,
            )
            
        except Exception as e:
            logger.error(f"ÂÄãÂà•Êé®Â•®‰∫ãÈ†ÖÁîüÊàê„Ç®„É©„Éº: {symbol} - {e}")
            return DiversificationRecommendation(
                symbol=symbol,
                timestamp=datetime.now(),
                current_diversification_level=current_level,
                recommended_actions=["ÂàÜÊûê„Ç®„É©„Éº"],
                suggested_sectors=[],
                suggested_stocks=[],
                risk_reduction_potential=0.0,
                priority_score=0.0,
            )

    async def _generate_portfolio_recommendation(
        self, symbols: List[str], current_level: DiversificationLevel,
        portfolio_value: float
    ) -> DiversificationRecommendation:
        """„Éù„Éº„Éà„Éï„Ç©„É™„Ç™ÂÖ®‰ΩìÊé®Â•®‰∫ãÈ†ÖÁîüÊàê"""
        try:
            recommended_actions = []
            suggested_sectors = []
            suggested_stocks = []
            
            # ÂàÜÊï£ÊäïË≥á„É¨„Éô„É´„Å´Âøú„Åò„ÅüÊé®Â•®‰∫ãÈ†Ö
            if current_level == DiversificationLevel.CRITICAL:
                recommended_actions.append("Á∑äÊÄ•„ÅÆÂàÜÊï£ÊäïË≥á„ÅåÂøÖË¶Å„Åß„Åô")
                recommended_actions.append("ÈäòÊüÑÊï∞„ÇíÂ§ßÂπÖ„Å´Â¢ó„ÇÑ„Åô„Åì„Å®„ÇíÊé®Â•®„Åó„Åæ„Åô")
                suggested_sectors = list(SectorType)[:5]  # ‰∏ªË¶Å5„Çª„ÇØ„Çø„Éº
            elif current_level == DiversificationLevel.POOR:
                recommended_actions.append("ÂàÜÊï£ÊäïË≥á„ÅÆÊîπÂñÑ„ÅåÂøÖË¶Å„Åß„Åô")
                recommended_actions.append("Áï∞„Å™„Çã„Çª„ÇØ„Çø„Éº„Å∏„ÅÆÊäïË≥á„ÇíÊ§úË®é„Åó„Å¶„Åè„Å†„Åï„ÅÑ")
                suggested_sectors = [s for s in SectorType if s != SectorType.UNKNOWN][:3]
            elif current_level == DiversificationLevel.FAIR:
                recommended_actions.append("ÂàÜÊï£ÊäïË≥á„ÅÆÊúÄÈÅ©Âåñ„ÇíÊé®Â•®„Åó„Åæ„Åô")
                suggested_sectors = [s for s in SectorType if s != SectorType.UNKNOWN][:2]
            else:
                recommended_actions.append("ÁèæÂú®„ÅÆÂàÜÊï£ÊäïË≥á„É¨„Éô„É´„ÅØÈÅ©Âàá„Åß„Åô")
            
            # Êé®Â•®ÈäòÊüÑ
            suggested_stocks = self._get_suggested_stocks(suggested_sectors)
            
            # „É™„Çπ„ÇØÂâäÊ∏õ„Éù„ÉÜ„É≥„Ç∑„É£„É´
            risk_reduction = self._calculate_portfolio_risk_reduction_potential(symbols)
            
            return DiversificationRecommendation(
                symbol="PORTFOLIO",
                timestamp=datetime.now(),
                current_diversification_level=current_level,
                recommended_actions=recommended_actions,
                suggested_sectors=suggested_sectors,
                suggested_stocks=suggested_stocks,
                risk_reduction_potential=risk_reduction,
                priority_score=1.0 if current_level in [DiversificationLevel.CRITICAL, DiversificationLevel.POOR] else 0.5,
            )
            
        except Exception as e:
            logger.error(f"„Éù„Éº„Éà„Éï„Ç©„É™„Ç™Êé®Â•®‰∫ãÈ†ÖÁîüÊàê„Ç®„É©„Éº: {e}")
            return DiversificationRecommendation(
                symbol="PORTFOLIO",
                timestamp=datetime.now(),
                current_diversification_level=current_level,
                recommended_actions=["ÂàÜÊûê„Ç®„É©„Éº"],
                suggested_sectors=[],
                suggested_stocks=[],
                risk_reduction_potential=0.0,
                priority_score=0.0,
            )

    def _get_suggested_sectors(
        self, current_sector: SectorType, sector_concentration: Dict[SectorType, float]
    ) -> List[SectorType]:
        """Êé®Â•®„Çª„ÇØ„Çø„ÉºÂèñÂæó"""
        try:
            # ÈõÜ‰∏≠Â∫¶„ÅÆ‰Ωé„ÅÑ„Çª„ÇØ„Çø„Éº„ÇíÊé®Â•®
            suggested_sectors = []
            
            for sector, weight in sector_concentration.items():
                if sector != current_sector and weight < self.diversification_params["max_sector_weight"]:
                    suggested_sectors.append(sector)
            
            # Êú™ÊäïË≥á„Çª„ÇØ„Çø„Éº„ÇíÂÑ™ÂÖà
            all_sectors = set(SectorType) - {SectorType.UNKNOWN}
            invested_sectors = set(sector_concentration.keys())
            uninvested_sectors = all_sectors - invested_sectors
            
            suggested_sectors = list(uninvested_sectors) + suggested_sectors
            
            return suggested_sectors[:3]  # ÊúÄÂ§ß3„Çª„ÇØ„Çø„Éº
        except Exception as e:
            logger.error(f"Êé®Â•®„Çª„ÇØ„Çø„ÉºÂèñÂæó„Ç®„É©„Éº: {e}")
            return []

    def _get_suggested_stocks(self, suggested_sectors: List[SectorType]) -> List[str]:
        """Êé®Â•®ÈäòÊüÑÂèñÂæó"""
        try:
            # „Çª„ÇØ„Çø„ÉºÂà•Êé®Â•®ÈäòÊüÑÔºàÁ∞°ÊòìÂÆüË£ÖÔºâ
            sector_stocks = {
                SectorType.TECHNOLOGY: ["AAPL", "GOOGL", "MSFT", "AMZN", "TSLA"],
                SectorType.FINANCIAL: ["JPM", "BAC", "WFC", "GS", "C"],
                SectorType.HEALTHCARE: ["JNJ", "PFE", "UNH", "ABBV", "MRK"],
                SectorType.CONSUMER: ["KO", "PEP", "WMT", "PG", "JNJ"],
                SectorType.INDUSTRIAL: ["BA", "CAT", "GE", "MMM", "HON"],
            }
            
            suggested_stocks = []
            for sector in suggested_sectors:
                if sector in sector_stocks:
                    suggested_stocks.extend(sector_stocks[sector][:2])  # „Çª„ÇØ„Çø„Éº„ÅÇ„Åü„Çä2ÈäòÊüÑ
            
            return suggested_stocks[:5]  # ÊúÄÂ§ß5ÈäòÊüÑ
        except Exception as e:
            logger.error(f"Êé®Â•®ÈäòÊüÑÂèñÂæó„Ç®„É©„Éº: {e}")
            return []

    def _calculate_risk_reduction_potential(self, symbol: str, all_symbols: List[str]) -> float:
        """„É™„Çπ„ÇØÂâäÊ∏õ„Éù„ÉÜ„É≥„Ç∑„É£„É´Ë®àÁÆó"""
        try:
            # Á∞°ÊòìÂÆüË£Ö: „Çª„ÇØ„Çø„ÉºÈõÜ‰∏≠Â∫¶„Å´Âü∫„Å•„ÅèË®àÁÆó
            sector_concentration = self._calculate_sector_concentration(all_symbols)
            current_sector = self.sector_mapping.get(symbol, SectorType.UNKNOWN)
            current_weight = sector_concentration.get(current_sector, 0.0)
            
            # ÈõÜ‰∏≠Â∫¶„ÅåÈ´ò„ÅÑ„Åª„Å©„É™„Çπ„ÇØÂâäÊ∏õ„Éù„ÉÜ„É≥„Ç∑„É£„É´„ÅåÈ´ò„ÅÑ
            if current_weight > self.diversification_params["max_sector_weight"]:
                return min(1.0, (current_weight - self.diversification_params["max_sector_weight"]) * 2)
            else:
                return 0.0
        except Exception as e:
            logger.error(f"„É™„Çπ„ÇØÂâäÊ∏õ„Éù„ÉÜ„É≥„Ç∑„É£„É´Ë®àÁÆó„Ç®„É©„Éº: {e}")
            return 0.0

    def _calculate_portfolio_risk_reduction_potential(self, symbols: List[str]) -> float:
        """„Éù„Éº„Éà„Éï„Ç©„É™„Ç™„É™„Çπ„ÇØÂâäÊ∏õ„Éù„ÉÜ„É≥„Ç∑„É£„É´Ë®àÁÆó"""
        try:
            # ÈäòÊüÑÊï∞‰∏çË∂≥„Å´„Çà„Çã„É™„Çπ„ÇØÂâäÊ∏õ„Éù„ÉÜ„É≥„Ç∑„É£„É´
            stock_count_potential = max(0, (self.diversification_params["min_stocks"] - len(symbols)) / 
                                      self.diversification_params["min_stocks"])
            
            # „Çª„ÇØ„Çø„ÉºÈõÜ‰∏≠Â∫¶„Å´„Çà„Çã„É™„Çπ„ÇØÂâäÊ∏õ„Éù„ÉÜ„É≥„Ç∑„É£„É´
            sector_concentration = self._calculate_sector_concentration(symbols)
            max_sector_weight = max(sector_concentration.values()) if sector_concentration else 0.0
            sector_potential = max(0, (max_sector_weight - self.diversification_params["max_sector_weight"]) / 
                                self.diversification_params["max_sector_weight"])
            
            # Á∑èÂêà„É™„Çπ„ÇØÂâäÊ∏õ„Éù„ÉÜ„É≥„Ç∑„É£„É´
            total_potential = (stock_count_potential * 0.6 + sector_potential * 0.4)
            
            return min(total_potential, 1.0)
        except Exception as e:
            logger.error(f"„Éù„Éº„Éà„Éï„Ç©„É™„Ç™„É™„Çπ„ÇØÂâäÊ∏õ„Éù„ÉÜ„É≥„Ç∑„É£„É´Ë®àÁÆó„Ç®„É©„Éº: {e}")
            return 0.0

    def _calculate_priority_score(
        self, symbol: str, current_level: DiversificationLevel, risk_reduction: float
    ) -> float:
        """ÂÑ™ÂÖàÂ∫¶„Çπ„Ç≥„Ç¢Ë®àÁÆó"""
        try:
            # ÂàÜÊï£ÊäïË≥á„É¨„Éô„É´„Å´„Çà„ÇãÂÑ™ÂÖàÂ∫¶
            level_priority = {
                DiversificationLevel.CRITICAL: 1.0,
                DiversificationLevel.POOR: 0.8,
                DiversificationLevel.FAIR: 0.6,
                DiversificationLevel.GOOD: 0.4,
                DiversificationLevel.EXCELLENT: 0.2,
            }.get(current_level, 0.5)
            
            # „É™„Çπ„ÇØÂâäÊ∏õ„Éù„ÉÜ„É≥„Ç∑„É£„É´„Å´„Çà„ÇãÂÑ™ÂÖàÂ∫¶
            risk_priority = risk_reduction
            
            # Á∑èÂêàÂÑ™ÂÖàÂ∫¶„Çπ„Ç≥„Ç¢
            total_priority = (level_priority * 0.6 + risk_priority * 0.4)
            
            return min(total_priority, 1.0)
        except Exception as e:
            logger.error(f"ÂÑ™ÂÖàÂ∫¶„Çπ„Ç≥„Ç¢Ë®àÁÆó„Ç®„É©„Éº: {e}")
            return 0.5

    def _create_default_correlation_metrics(self) -> CorrelationMetrics:
        """„Éá„Éï„Ç©„É´„ÉàÁõ∏Èñ¢ÊåáÊ®ô‰ΩúÊàê"""
        return CorrelationMetrics(
            symbol="PORTFOLIO",
            timestamp=datetime.now(),
            correlation_matrix={},
            average_correlation=0.0,
            max_correlation=0.0,
            correlation_risk_score=0.5,
            diversification_score=0.5,
            concentration_risk=0.5,
            sector_concentration={},
            cluster_analysis={"clusters": [], "cluster_count": 0},
        )

    def get_correlation_summary(self) -> Dict[str, Any]:
        """Áõ∏Èñ¢ÂàÜÊûê„Çµ„Éû„É™„ÉºÂèñÂæó"""
        try:
            if not self.correlation_history:
                return {"message": "Áõ∏Èñ¢ÂàÜÊûêÂ±•Ê≠¥„Åå„ÅÇ„Çä„Åæ„Åõ„Çì"}
            
            summary = {
                "timestamp": datetime.now().isoformat(),
                "correlation_analysis": {},
                "diversification_recommendations": [],
            }
            
            # ÊúÄÊñ∞„ÅÆÁõ∏Èñ¢ÂàÜÊûêÁµêÊûú
            if "PORTFOLIO" in self.correlation_history:
                latest_analysis = self.correlation_history["PORTFOLIO"][-1]
                summary["correlation_analysis"] = asdict(latest_analysis)
            
            return summary
        except Exception as e:
            logger.error(f"Áõ∏Èñ¢ÂàÜÊûê„Çµ„Éû„É™„ÉºÂèñÂæó„Ç®„É©„Éº: {e}")
            return {"error": str(e)}

    def save_correlation_report(self, filename: str = "correlation_analysis_report.json"):
        """Áõ∏Èñ¢ÂàÜÊûê„É¨„Éù„Éº„Éà‰øùÂ≠ò"""
        try:
            report = self.get_correlation_summary()
            with open(filename, "w", encoding="utf-8") as f:
                json.dump(report, f, ensure_ascii=False, indent=2, default=str)
            logger.info(f"Áõ∏Èñ¢ÂàÜÊûê„É¨„Éù„Éº„Éà„Çí‰øùÂ≠ò„Åó„Åæ„Åó„Åü: {filename}")
        except Exception as e:
            logger.error(f"„É¨„Éù„Éº„Éà‰øùÂ≠ò„Ç®„É©„Éº: {e}")


async def main():
    """„É°„Ç§„É≥ÂÆüË°åÈñ¢Êï∞"""
    # Áõ∏Èñ¢ÂàÜÊûê„Ç∑„Çπ„ÉÜ„É†ÂàùÊúüÂåñ
    correlation_system = CorrelationAnalysisSystem()
    
    # „ÉÜ„Çπ„ÉàÈäòÊüÑ
    test_symbols = ["7203.T", "6758.T", "9984.T", "7974.T", "4063.T"]
    
    logger.info("Áõ∏Èñ¢ÂàÜÊûê„Ç∑„Çπ„ÉÜ„É† „ÉÜ„Çπ„ÉàÈñãÂßã")
    
    # Áõ∏Èñ¢„É™„Çπ„ÇØÂàÜÊûê
    try:
        logger.info("Áõ∏Èñ¢„É™„Çπ„ÇØÂàÜÊûêÂÆüË°å‰∏≠...")
        correlation_metrics = await correlation_system.analyze_correlation_risk(test_symbols)
        
        logger.info(f"Áõ∏Èñ¢ÂàÜÊûêÂÆå‰∫Ü:")
        logger.info(f"  Âπ≥ÂùáÁõ∏Èñ¢: {correlation_metrics.average_correlation:.3f}")
        logger.info(f"  ÊúÄÂ§ßÁõ∏Èñ¢: {correlation_metrics.max_correlation:.3f}")
        logger.info(f"  Áõ∏Èñ¢„É™„Çπ„ÇØ„Çπ„Ç≥„Ç¢: {correlation_metrics.correlation_risk_score:.3f}")
        logger.info(f"  ÂàÜÊï£ÊäïË≥á„Çπ„Ç≥„Ç¢: {correlation_metrics.diversification_score:.3f}")
        logger.info(f"  ÈõÜ‰∏≠Â∫¶„É™„Çπ„ÇØ: {correlation_metrics.concentration_risk:.3f}")
        
        # „Çª„ÇØ„Çø„ÉºÈõÜ‰∏≠Â∫¶Ë°®Á§∫
        print("\nüìä „Çª„ÇØ„Çø„ÉºÈõÜ‰∏≠Â∫¶:")
        for sector, weight in correlation_metrics.sector_concentration.items():
            print(f"  {sector.value}: {weight:.1%}")
        
        # „ÇØ„É©„Çπ„Çø„ÉºÂàÜÊûêÁµêÊûú
        print(f"\nüîó „ÇØ„É©„Çπ„Çø„ÉºÂàÜÊûê:")
        print(f"  „ÇØ„É©„Çπ„Çø„ÉºÊï∞: {correlation_metrics.cluster_analysis['cluster_count']}")
        for i, cluster in enumerate(correlation_metrics.cluster_analysis['clusters']):
            print(f"  „ÇØ„É©„Çπ„Çø„Éº{i+1}: {', '.join(cluster)}")
        
    except Exception as e:
        logger.error(f"Áõ∏Èñ¢ÂàÜÊûê„Ç®„É©„Éº: {e}")
    
    # ÂàÜÊï£ÊäïË≥áÊé®Â•®ÁîüÊàê
    try:
        logger.info("ÂàÜÊï£ÊäïË≥áÊé®Â•®ÁîüÊàê‰∏≠...")
        recommendations = await correlation_system.generate_diversification_recommendations(
            test_symbols, portfolio_value=1000000
        )
        
        logger.info(f"ÂàÜÊï£ÊäïË≥áÊé®Â•®ÁîüÊàêÂÆå‰∫Ü: {len(recommendations)}‰ª∂")
        
        # Êé®Â•®‰∫ãÈ†ÖË°®Á§∫
        print("\nüí° ÂàÜÊï£ÊäïË≥áÊé®Â•®‰∫ãÈ†Ö:")
        for rec in recommendations:
            print(f"\n  {rec.symbol}:")
            print(f"    ÂàÜÊï£ÊäïË≥á„É¨„Éô„É´: {rec.current_diversification_level.value}")
            print(f"    ÂÑ™ÂÖàÂ∫¶„Çπ„Ç≥„Ç¢: {rec.priority_score:.3f}")
            print(f"    „É™„Çπ„ÇØÂâäÊ∏õ„Éù„ÉÜ„É≥„Ç∑„É£„É´: {rec.risk_reduction_potential:.1%}")
            print(f"    Êé®Â•®„Ç¢„ÇØ„Ç∑„Éß„É≥: {', '.join(rec.recommended_actions)}")
            if rec.suggested_sectors:
                print(f"    Êé®Â•®„Çª„ÇØ„Çø„Éº: {[s.value for s in rec.suggested_sectors]}")
            if rec.suggested_stocks:
                print(f"    Êé®Â•®ÈäòÊüÑ: {rec.suggested_stocks}")
        
    except Exception as e:
        logger.error(f"ÂàÜÊï£ÊäïË≥áÊé®Â•®ÁîüÊàê„Ç®„É©„Éº: {e}")
    
    # „É¨„Éù„Éº„Éà‰øùÂ≠ò
    correlation_system.save_correlation_report()
    
    # ÁµêÊûúË°®Á§∫
    print("\n" + "=" * 80)
    print("üîó Áõ∏Èñ¢ÂàÜÊûê„Ç∑„Çπ„ÉÜ„É† „É¨„Éù„Éº„Éà")
    print("=" * 80)
    print(f"ÂàÜÊûêÈäòÊüÑÊï∞: {len(test_symbols)}")
    print(f"Êé®Â•®‰∫ãÈ†ÖÊï∞: {len(recommendations) if 'recommendations' in locals() else 0}")


if __name__ == "__main__":
    asyncio.run(main())
