#!/usr/bin/env python3
"""
Ëá™ÂãïÂèñÂºïÂÆüË°å„Ç∑„Çπ„ÉÜ„É†
„É™„Ç¢„É´„Çø„Ç§„É†Ëá™ÂãïÂ£≤Ë≤∑„Ç∑„Çπ„ÉÜ„É†„ÅÆËøΩÂä†Êé®Â•®Ê©üËÉΩ

ÊúüÂæÖÂäπÊûú: ÊúàÈñì10-20%„ÅÆÂà©ÁõäÂêë‰∏ä
ÂÆüË£ÖÈõ£ÊòìÂ∫¶: üü° Medium
Êé®ÂÆöÂ∑•Êï∞: 3-4Êó•

‰∏ªË¶ÅÊ©üËÉΩ:
1. „Éñ„É≠„Éº„Ç´„ÉºAPIÈÄ£Êê∫
2. Ëá™ÂãïÊ≥®ÊñáÂÆüË°å
3. Ê≥®ÊñáÁä∂ÊÖãÁõ£Ë¶ñ
4. ÂèñÂºïÂ±•Ê≠¥ÁÆ°ÁêÜ
"""

import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from typing import Dict, List, Tuple, Optional, Union
import json
import logging
from dataclasses import dataclass, asdict
from enum import Enum
import warnings
import threading
import time
import asyncio
import requests
from concurrent.futures import ThreadPoolExecutor
import hashlib
import hmac
import base64
from urllib.parse import urlencode

warnings.filterwarnings("ignore")

# „É≠„Ç∞Ë®≠ÂÆö
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    handlers=[logging.FileHandler("automated_trading.log"), logging.StreamHandler()],
)
logger = logging.getLogger(__name__)


class OrderType(Enum):
    """Ê≥®Êñá„Çø„Ç§„Éó"""

    MARKET = "market"
    LIMIT = "limit"
    STOP = "stop"
    STOP_LIMIT = "stop_limit"


class OrderSide(Enum):
    """Ê≥®Êñá„Çµ„Ç§„Éâ"""

    BUY = "buy"
    SELL = "sell"


class OrderStatus(Enum):
    """Ê≥®Êñá„Çπ„ÉÜ„Éº„Çø„Çπ"""

    PENDING = "pending"
    SUBMITTED = "submitted"
    FILLED = "filled"
    PARTIALLY_FILLED = "partially_filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"
    EXPIRED = "expired"


class BrokerType(Enum):
    """„Éñ„É≠„Éº„Ç´„Éº„Çø„Ç§„Éó"""

    SBI = "sbi"
    RAKUTEN = "rakuten"
    MATSUI = "matsui"
    MOCK = "mock"  # „ÉÜ„Çπ„ÉàÁî®


@dataclass
class Order:
    """Ê≥®Êñá„ÇØ„É©„Çπ"""

    order_id: str
    symbol: str
    side: OrderSide
    order_type: OrderType
    quantity: int
    price: Optional[float]
    stop_price: Optional[float]
    status: OrderStatus
    created_at: datetime
    filled_at: Optional[datetime]
    filled_price: Optional[float]
    filled_quantity: int
    remaining_quantity: int
    commission: float
    notes: str = ""


@dataclass
class Trade:
    """ÂèñÂºï„ÇØ„É©„Çπ"""

    trade_id: str
    order_id: str
    symbol: str
    side: OrderSide
    quantity: int
    price: float
    timestamp: datetime
    commission: float
    pnl: float = 0.0


@dataclass
class Position:
    """„Éù„Ç∏„Ç∑„Éß„É≥„ÇØ„É©„Çπ"""

    symbol: str
    quantity: int
    average_price: float
    current_price: float
    unrealized_pnl: float
    realized_pnl: float
    last_updated: datetime


class BrokerAPI:
    """„Éñ„É≠„Éº„Ç´„ÉºAPIÂü∫Â∫ï„ÇØ„É©„Çπ"""

    def __init__(self, api_key: str, secret_key: str, base_url: str):
        self.api_key = api_key
        self.secret_key = secret_key
        self.base_url = base_url
        self.session = requests.Session()

    def _generate_signature(self, params: Dict, timestamp: str) -> str:
        """ÁΩ≤Âêç„ÇíÁîüÊàê"""
        message = f"{timestamp}{json.dumps(params, sort_keys=True)}"
        signature = hmac.new(
            self.secret_key.encode("utf-8"), message.encode("utf-8"), hashlib.sha256
        ).hexdigest()
        return signature

    def _get_headers(self, params: Dict = None) -> Dict[str, str]:
        """„Éò„ÉÉ„ÉÄ„Éº„ÇíÂèñÂæó"""
        timestamp = str(int(time.time() * 1000))
        signature = self._generate_signature(params or {}, timestamp)

        return {
            "Content-Type": "application/json",
            "X-API-Key": self.api_key,
            "X-Timestamp": timestamp,
            "X-Signature": signature,
        }

    def get_account_info(self) -> Dict:
        """Âè£Â∫ßÊÉÖÂ†±„ÇíÂèñÂæó"""
        raise NotImplementedError

    def get_positions(self) -> List[Position]:
        """„Éù„Ç∏„Ç∑„Éß„É≥ÊÉÖÂ†±„ÇíÂèñÂæó"""
        raise NotImplementedError

    def place_order(self, order: Order) -> str:
        """Ê≥®Êñá„ÇíÁô∫Ê≥®"""
        raise NotImplementedError

    def cancel_order(self, order_id: str) -> bool:
        """Ê≥®Êñá„Çí„Ç≠„É£„É≥„Çª„É´"""
        raise NotImplementedError

    def get_order_status(self, order_id: str) -> OrderStatus:
        """Ê≥®Êñá„Çπ„ÉÜ„Éº„Çø„Çπ„ÇíÂèñÂæó"""
        raise NotImplementedError

    def get_order_history(self, symbol: str = None, limit: int = 100) -> List[Order]:
        """Ê≥®ÊñáÂ±•Ê≠¥„ÇíÂèñÂæó"""
        raise NotImplementedError


class MockBrokerAPI(BrokerAPI):
    """„É¢„ÉÉ„ÇØ„Éñ„É≠„Éº„Ç´„ÉºAPIÔºà„ÉÜ„Çπ„ÉàÁî®Ôºâ"""

    def __init__(self):
        super().__init__("mock_api_key", "mock_secret_key", "https://mock-api.com")
        self.orders = {}
        self.positions = {}
        self.account_balance = 1000000.0
        self.order_counter = 0

    def get_account_info(self) -> Dict:
        """Âè£Â∫ßÊÉÖÂ†±„ÇíÂèñÂæó"""
        return {
            "balance": self.account_balance,
            "equity": self.account_balance
            + sum(pos.unrealized_pnl for pos in self.positions.values()),
            "margin_used": 0.0,
            "margin_available": self.account_balance,
        }

    def get_positions(self) -> List[Position]:
        """„Éù„Ç∏„Ç∑„Éß„É≥ÊÉÖÂ†±„ÇíÂèñÂæó"""
        return list(self.positions.values())

    def place_order(self, order: Order) -> str:
        """Ê≥®Êñá„ÇíÁô∫Ê≥®"""
        self.order_counter += 1
        order_id = f"ORDER_{self.order_counter:06d}"
        order.order_id = order_id
        order.status = OrderStatus.SUBMITTED
        order.created_at = datetime.now()

        # „É¢„ÉÉ„ÇØÂá¶ÁêÜÔºöÂç≥Â∫ß„Å´Á¥ÑÂÆö
        if order.order_type == OrderType.MARKET:
            order.status = OrderStatus.FILLED
            order.filled_at = datetime.now()
            order.filled_price = order.price or 1000.0  # „Éá„Éï„Ç©„É´„Éà‰æ°Ê†º
            order.filled_quantity = order.quantity
            order.remaining_quantity = 0
            order.commission = (
                order.filled_price * order.filled_quantity * 0.001
            )  # 0.1%ÊâãÊï∞Êñô

        self.orders[order_id] = order

        # „Éù„Ç∏„Ç∑„Éß„É≥„ÇíÊõ¥Êñ∞
        if order.status == OrderStatus.FILLED:
            self._update_position(order)

        logger.info(
            f"Ê≥®ÊñáÁô∫Ê≥®: {order_id} - {order.symbol} {order.side.value} {order.quantity}Ê†™"
        )
        return order_id

    def cancel_order(self, order_id: str) -> bool:
        """Ê≥®Êñá„Çí„Ç≠„É£„É≥„Çª„É´"""
        if order_id in self.orders:
            self.orders[order_id].status = OrderStatus.CANCELLED
            logger.info(f"Ê≥®Êñá„Ç≠„É£„É≥„Çª„É´: {order_id}")
            return True
        return False

    def get_order_status(self, order_id: str) -> OrderStatus:
        """Ê≥®Êñá„Çπ„ÉÜ„Éº„Çø„Çπ„ÇíÂèñÂæó"""
        if order_id in self.orders:
            return self.orders[order_id].status
        return OrderStatus.REJECTED

    def get_order_history(self, symbol: str = None, limit: int = 100) -> List[Order]:
        """Ê≥®ÊñáÂ±•Ê≠¥„ÇíÂèñÂæó"""
        orders = list(self.orders.values())
        if symbol:
            orders = [o for o in orders if o.symbol == symbol]
        return sorted(orders, key=lambda x: x.created_at, reverse=True)[:limit]

    def _update_position(self, order: Order):
        """„Éù„Ç∏„Ç∑„Éß„É≥„ÇíÊõ¥Êñ∞"""
        symbol = order.symbol
        if symbol not in self.positions:
            self.positions[symbol] = Position(
                symbol=symbol,
                quantity=0,
                average_price=0.0,
                current_price=order.filled_price,
                unrealized_pnl=0.0,
                realized_pnl=0.0,
                last_updated=datetime.now(),
            )

        position = self.positions[symbol]

        if order.side == OrderSide.BUY:
            # Ë≤∑„ÅÑÊ≥®Êñá
            if position.quantity >= 0:
                # Êñ∞Ë¶èË≤∑„ÅÑ„Åæ„Åü„ÅØË≤∑„ÅÑÂ¢ó„Åó
                total_cost = (
                    position.quantity * position.average_price
                    + order.filled_quantity * order.filled_price
                )
                position.quantity += order.filled_quantity
                position.average_price = total_cost / position.quantity
            else:
                # Á©∫Â£≤„ÇäÊ±∫Ê∏à
                if order.filled_quantity <= abs(position.quantity):
                    # ÈÉ®ÂàÜÊ±∫Ê∏à
                    position.realized_pnl += (
                        position.average_price - order.filled_price
                    ) * order.filled_quantity
                    position.quantity += order.filled_quantity
                else:
                    # ÂÆåÂÖ®Ê±∫Ê∏à + Êñ∞Ë¶èË≤∑„ÅÑ
                    position.realized_pnl += (
                        position.average_price - order.filled_price
                    ) * abs(position.quantity)
                    remaining_quantity = order.filled_quantity - abs(position.quantity)
                    position.quantity = remaining_quantity
                    position.average_price = order.filled_price

        else:
            # Â£≤„ÇäÊ≥®Êñá
            if position.quantity <= 0:
                # Êñ∞Ë¶èÂ£≤„Çä„Åæ„Åü„ÅØÂ£≤„ÇäÂ¢ó„Åó
                total_cost = (
                    abs(position.quantity) * position.average_price
                    + order.filled_quantity * order.filled_price
                )
                position.quantity -= order.filled_quantity
                position.average_price = total_cost / abs(position.quantity)
            else:
                # Ë≤∑„ÅÑ„Éù„Ç∏„Ç∑„Éß„É≥Ê±∫Ê∏à
                if order.filled_quantity <= position.quantity:
                    # ÈÉ®ÂàÜÊ±∫Ê∏à
                    position.realized_pnl += (
                        order.filled_price - position.average_price
                    ) * order.filled_quantity
                    position.quantity -= order.filled_quantity
                else:
                    # ÂÆåÂÖ®Ê±∫Ê∏à + Êñ∞Ë¶èÂ£≤„Çä
                    position.realized_pnl += (
                        order.filled_price - position.average_price
                    ) * position.quantity
                    remaining_quantity = order.filled_quantity - position.quantity
                    position.quantity = -remaining_quantity
                    position.average_price = order.filled_price

        position.current_price = order.filled_price
        position.last_updated = datetime.now()

        # Êú™ÂÆüÁèæÊêçÁõä„ÇíË®àÁÆó
        if position.quantity != 0:
            if position.quantity > 0:
                position.unrealized_pnl = (
                    position.current_price - position.average_price
                ) * position.quantity
            else:
                position.unrealized_pnl = (
                    position.average_price - position.current_price
                ) * abs(position.quantity)


class TradingExecutionEngine:
    """ÂèñÂºïÂÆüË°å„Ç®„É≥„Ç∏„É≥"""

    def __init__(self, broker_api: BrokerAPI):
        self.broker_api = broker_api
        self.active_orders = {}
        self.execution_queue = []
        self.is_running = False
        self.execution_thread = None

    def start(self):
        """ÂÆüË°å„Ç®„É≥„Ç∏„É≥„ÇíÈñãÂßã"""
        if not self.is_running:
            self.is_running = True
            self.execution_thread = threading.Thread(target=self._execution_loop)
            self.execution_thread.daemon = True
            self.execution_thread.start()
            logger.info("ÂèñÂºïÂÆüË°å„Ç®„É≥„Ç∏„É≥„ÇíÈñãÂßã„Åó„Åæ„Åó„Åü")

    def stop(self):
        """ÂÆüË°å„Ç®„É≥„Ç∏„É≥„ÇíÂÅúÊ≠¢"""
        self.is_running = False
        if self.execution_thread:
            self.execution_thread.join()
        logger.info("ÂèñÂºïÂÆüË°å„Ç®„É≥„Ç∏„É≥„ÇíÂÅúÊ≠¢„Åó„Åæ„Åó„Åü")

    def _execution_loop(self):
        """ÂÆüË°å„É´„Éº„Éó"""
        while self.is_running:
            try:
                # ÂÆüË°å„Ç≠„É•„Éº„Åã„ÇâÊ≥®Êñá„ÇíÂá¶ÁêÜ
                if self.execution_queue:
                    order = self.execution_queue.pop(0)
                    self._execute_order(order)

                # „Ç¢„ÇØ„ÉÜ„Ç£„ÉñÊ≥®Êñá„ÅÆ„Çπ„ÉÜ„Éº„Çø„Çπ„ÇíÁ¢∫Ë™ç
                self._monitor_active_orders()

                time.sleep(1)  # 1ÁßíÈñìÈöî„Åß„ÉÅ„Çß„ÉÉ„ÇØ

            except Exception as e:
                logger.error(f"ÂÆüË°å„É´„Éº„Éó„Ç®„É©„Éº: {e}")
                time.sleep(5)

    def _execute_order(self, order: Order):
        """Ê≥®Êñá„ÇíÂÆüË°å"""
        try:
            # Âè£Â∫ßÊÆãÈ´ò„Çí„ÉÅ„Çß„ÉÉ„ÇØ
            if not self._check_account_balance(order):
                order.status = OrderStatus.REJECTED
                order.notes = "ÊÆãÈ´ò‰∏çË∂≥"
                logger.warning(f"ÊÆãÈ´ò‰∏çË∂≥„ÅßÊ≥®Êñá„ÇíÊãíÂê¶: {order.symbol}")
                return

            # Ê≥®Êñá„ÇíÁô∫Ê≥®
            order_id = self.broker_api.place_order(order)
            if order_id:
                order.order_id = order_id
                self.active_orders[order_id] = order
                logger.info(f"Ê≥®Êñá„ÇíÁô∫Ê≥®„Åó„Åæ„Åó„Åü: {order_id}")
            else:
                order.status = OrderStatus.REJECTED
                order.notes = "API „Ç®„É©„Éº"
                logger.error(f"Ê≥®ÊñáÁô∫Ê≥®„Å´Â§±Êïó: {order.symbol}")

        except Exception as e:
            order.status = OrderStatus.REJECTED
            order.notes = f"ÂÆüË°å„Ç®„É©„Éº: {str(e)}"
            logger.error(f"Ê≥®ÊñáÂÆüË°å„Ç®„É©„Éº: {e}")

    def _check_account_balance(self, order: Order) -> bool:
        """Âè£Â∫ßÊÆãÈ´ò„Çí„ÉÅ„Çß„ÉÉ„ÇØ"""
        try:
            account_info = self.broker_api.get_account_info()
            required_margin = order.quantity * (order.price or 1000.0) * 1.1  # 10%„ÅÆ„Éû„Éº„Ç∏„É≥
            return account_info["margin_available"] >= required_margin
        except:
            return True  # „ÉÅ„Çß„ÉÉ„ÇØ„Åß„Åç„Å™„ÅÑÂ†¥Âêà„ÅØË®±ÂèØ

    def _monitor_active_orders(self):
        """„Ç¢„ÇØ„ÉÜ„Ç£„ÉñÊ≥®Êñá„ÇíÁõ£Ë¶ñ"""
        completed_orders = []

        for order_id, order in self.active_orders.items():
            try:
                status = self.broker_api.get_order_status(order_id)
                if status != order.status:
                    order.status = status
                    logger.info(f"Ê≥®Êñá„Çπ„ÉÜ„Éº„Çø„ÇπÊõ¥Êñ∞: {order_id} - {status.value}")

                # Á¥ÑÂÆö„Åæ„Åü„ÅØ„Ç≠„É£„É≥„Çª„É´„Åï„Çå„ÅüÊ≥®Êñá„ÇíÂá¶ÁêÜ
                if status in [
                    OrderStatus.FILLED,
                    OrderStatus.CANCELLED,
                    OrderStatus.REJECTED,
                ]:
                    completed_orders.append(order_id)

            except Exception as e:
                logger.error(f"Ê≥®ÊñáÁõ£Ë¶ñ„Ç®„É©„Éº: {order_id} - {e}")

        # ÂÆå‰∫Ü„Åó„ÅüÊ≥®Êñá„ÇíÂâäÈô§
        for order_id in completed_orders:
            del self.active_orders[order_id]

    def submit_order(self, order: Order) -> str:
        """Ê≥®Êñá„ÇíÊèêÂá∫"""
        self.execution_queue.append(order)
        logger.info(f"Ê≥®Êñá„Çí„Ç≠„É•„Éº„Å´ËøΩÂä†: {order.symbol} {order.side.value} {order.quantity}Ê†™")
        return order.order_id

    def cancel_order(self, order_id: str) -> bool:
        """Ê≥®Êñá„Çí„Ç≠„É£„É≥„Çª„É´"""
        try:
            if order_id in self.active_orders:
                success = self.broker_api.cancel_order(order_id)
                if success:
                    self.active_orders[order_id].status = OrderStatus.CANCELLED
                    logger.info(f"Ê≥®Êñá„Çí„Ç≠„É£„É≥„Çª„É´„Åó„Åæ„Åó„Åü: {order_id}")
                return success
            return False
        except Exception as e:
            logger.error(f"Ê≥®Êñá„Ç≠„É£„É≥„Çª„É´„Ç®„É©„Éº: {order_id} - {e}")
            return False

    def get_active_orders(self) -> List[Order]:
        """„Ç¢„ÇØ„ÉÜ„Ç£„ÉñÊ≥®Êñá„ÇíÂèñÂæó"""
        return list(self.active_orders.values())

    def get_order_history(self, symbol: str = None, limit: int = 100) -> List[Order]:
        """Ê≥®ÊñáÂ±•Ê≠¥„ÇíÂèñÂæó"""
        return self.broker_api.get_order_history(symbol, limit)


class AutomatedTradingSystem:
    """Ëá™ÂãïÂèñÂºï„Ç∑„Çπ„ÉÜ„É†"""

    def __init__(self, broker_type: BrokerType = BrokerType.MOCK):
        self.broker_type = broker_type
        self.broker_api = self._create_broker_api()
        self.execution_engine = TradingExecutionEngine(self.broker_api)
        self.is_running = False

        logger.info(f"Ëá™ÂãïÂèñÂºï„Ç∑„Çπ„ÉÜ„É†„ÇíÂàùÊúüÂåñ„Åó„Åæ„Åó„Åü: {broker_type.value}")

    def _create_broker_api(self) -> BrokerAPI:
        """„Éñ„É≠„Éº„Ç´„ÉºAPI„Çí‰ΩúÊàê"""
        if self.broker_type == BrokerType.MOCK:
            return MockBrokerAPI()
        else:
            # ÂÆüÈöõ„ÅÆ„Éñ„É≠„Éº„Ç´„ÉºAPIÂÆüË£Ö
            raise NotImplementedError(f"Êú™ÂØæÂøú„ÅÆ„Éñ„É≠„Éº„Ç´„Éº: {self.broker_type.value}")

    def start_trading(self):
        """ÂèñÂºï„ÇíÈñãÂßã"""
        if not self.is_running:
            self.is_running = True
            self.execution_engine.start()
            logger.info("Ëá™ÂãïÂèñÂºï„ÇíÈñãÂßã„Åó„Åæ„Åó„Åü")

    def stop_trading(self):
        """ÂèñÂºï„ÇíÂÅúÊ≠¢"""
        if self.is_running:
            self.is_running = False
            self.execution_engine.stop()
            logger.info("Ëá™ÂãïÂèñÂºï„ÇíÂÅúÊ≠¢„Åó„Åæ„Åó„Åü")

    def place_buy_order(
        self,
        symbol: str,
        quantity: int,
        price: float = None,
        order_type: OrderType = OrderType.MARKET,
    ) -> str:
        """Ë≤∑„ÅÑÊ≥®Êñá„ÇíÁô∫Ê≥®"""
        order = Order(
            order_id="",
            symbol=symbol,
            side=OrderSide.BUY,
            order_type=order_type,
            quantity=quantity,
            price=price,
            stop_price=None,
            status=OrderStatus.PENDING,
            created_at=datetime.now(),
            filled_at=None,
            filled_price=None,
            filled_quantity=0,
            remaining_quantity=quantity,
            commission=0.0,
        )

        return self.execution_engine.submit_order(order)

    def place_sell_order(
        self,
        symbol: str,
        quantity: int,
        price: float = None,
        order_type: OrderType = OrderType.MARKET,
    ) -> str:
        """Â£≤„ÇäÊ≥®Êñá„ÇíÁô∫Ê≥®"""
        order = Order(
            order_id="",
            symbol=symbol,
            side=OrderSide.SELL,
            order_type=order_type,
            quantity=quantity,
            price=price,
            stop_price=None,
            status=OrderStatus.PENDING,
            created_at=datetime.now(),
            filled_at=None,
            filled_price=None,
            filled_quantity=0,
            remaining_quantity=quantity,
            commission=0.0,
        )

        return self.execution_engine.submit_order(order)

    def get_positions(self) -> List[Position]:
        """„Éù„Ç∏„Ç∑„Éß„É≥ÊÉÖÂ†±„ÇíÂèñÂæó"""
        return self.broker_api.get_positions()

    def get_account_info(self) -> Dict:
        """Âè£Â∫ßÊÉÖÂ†±„ÇíÂèñÂæó"""
        return self.broker_api.get_account_info()

    def get_active_orders(self) -> List[Order]:
        """„Ç¢„ÇØ„ÉÜ„Ç£„ÉñÊ≥®Êñá„ÇíÂèñÂæó"""
        return self.execution_engine.get_active_orders()

    def cancel_order(self, order_id: str) -> bool:
        """Ê≥®Êñá„Çí„Ç≠„É£„É≥„Çª„É´"""
        return self.execution_engine.cancel_order(order_id)

    def get_trading_summary(self) -> Dict:
        """ÂèñÂºï„Çµ„Éû„É™„Éº„ÇíÂèñÂæó"""
        positions = self.get_positions()
        account_info = self.get_account_info()
        active_orders = self.get_active_orders()

        total_unrealized_pnl = sum(pos.unrealized_pnl for pos in positions)
        total_realized_pnl = sum(pos.realized_pnl for pos in positions)

        return {
            "account_balance": account_info["balance"],
            "equity": account_info["equity"],
            "total_positions": len(positions),
            "total_unrealized_pnl": total_unrealized_pnl,
            "total_realized_pnl": total_realized_pnl,
            "active_orders": len(active_orders),
            "system_running": self.is_running,
            "last_update": datetime.now().isoformat(),
        }


def main():
    """„É°„Ç§„É≥Èñ¢Êï∞Ôºà„ÉÜ„Çπ„ÉàÁî®Ôºâ"""
    # Ëá™ÂãïÂèñÂºï„Ç∑„Çπ„ÉÜ„É†„ÇíÂàùÊúüÂåñ
    trading_system = AutomatedTradingSystem(BrokerType.MOCK)

    # ÂèñÂºï„ÇíÈñãÂßã
    trading_system.start_trading()

    try:
        # „ÉÜ„Çπ„ÉàÁî®„ÅÆÊ≥®Êñá„ÇíÁô∫Ê≥®
        print("=== Ëá™ÂãïÂèñÂºï„Ç∑„Çπ„ÉÜ„É†„ÉÜ„Çπ„Éà ===")

        # Ë≤∑„ÅÑÊ≥®Êñá„ÇíÁô∫Ê≥®
        buy_order_id = trading_system.place_buy_order(
            "7203", 100, 2500.0, OrderType.MARKET
        )
        print(f"Ë≤∑„ÅÑÊ≥®ÊñáÁô∫Ê≥®: {buy_order_id}")

        # Â£≤„ÇäÊ≥®Êñá„ÇíÁô∫Ê≥®
        sell_order_id = trading_system.place_sell_order(
            "6758", 50, 12000.0, OrderType.LIMIT
        )
        print(f"Â£≤„ÇäÊ≥®ÊñáÁô∫Ê≥®: {sell_order_id}")

        # Â∞ë„ÅóÂæÖÊ©ü
        time.sleep(2)

        # Âè£Â∫ßÊÉÖÂ†±„ÇíË°®Á§∫
        account_info = trading_system.get_account_info()
        print(f"\n=== Âè£Â∫ßÊÉÖÂ†± ===")
        print(f"ÊÆãÈ´ò: ¬•{account_info['balance']:,.0f}")
        print(f"Ë©ï‰æ°È°ç: ¬•{account_info['equity']:,.0f}")

        # „Éù„Ç∏„Ç∑„Éß„É≥ÊÉÖÂ†±„ÇíË°®Á§∫
        positions = trading_system.get_positions()
        print(f"\n=== „Éù„Ç∏„Ç∑„Éß„É≥ÊÉÖÂ†± ===")
        for pos in positions:
            print(f"{pos.symbol}: {pos.quantity}Ê†™ @ ¬•{pos.average_price:.2f}")
            print(f"  Êú™ÂÆüÁèæÊêçÁõä: ¬•{pos.unrealized_pnl:,.0f}")

        # „Ç¢„ÇØ„ÉÜ„Ç£„ÉñÊ≥®Êñá„ÇíË°®Á§∫
        active_orders = trading_system.get_active_orders()
        print(f"\n=== „Ç¢„ÇØ„ÉÜ„Ç£„ÉñÊ≥®Êñá ===")
        for order in active_orders:
            print(
                f"{order.symbol} {order.side.value} {order.quantity}Ê†™ - {order.status.value}"
            )

        # ÂèñÂºï„Çµ„Éû„É™„Éº„ÇíË°®Á§∫
        summary = trading_system.get_trading_summary()
        print(f"\n=== ÂèñÂºï„Çµ„Éû„É™„Éº ===")
        for key, value in summary.items():
            print(f"{key}: {value}")

    finally:
        # ÂèñÂºï„ÇíÂÅúÊ≠¢
        trading_system.stop_trading()
        print("\nËá™ÂãïÂèñÂºï„Ç∑„Çπ„ÉÜ„É†„ÇíÂÅúÊ≠¢„Åó„Åæ„Åó„Åü")


if __name__ == "__main__":
    main()
